"""
main_crossplatform.py
Cross-platform Secure Formatter (Linux & Windows compatible)
Project ASH - Code Monk Secure Formatter
"""
import os
import sys
import threading
import time
import tempfile
import shutil
import subprocess
import datetime
import platform
from pathlib import Path

# Import compatibility layer
from linux_compat import (
    is_admin, detect_drives, get_wipe_commands, 
    execute_secure_command, create_cross_platform_app
)

try:
    from PyQt5 import QtWidgets, QtGui, QtCore
    QT_AVAILABLE = True
except ImportError:
    try:
        from PyQt6 import QtWidgets, QtGui, QtCore
        QT_AVAILABLE = True
    except ImportError:
        QT_AVAILABLE = False

try:
    from reportlab.lib.pagesizes import A4
    from reportlab.pdfgen import canvas
    from PIL import Image
    PDF_AVAILABLE = True
except ImportError:
    PDF_AVAILABLE = False

# Configuration
APP_TITLE = "Code Monk — Cross-Platform Secure Formatter"
COMPANY_NAME = "Code Monk"
LOGO_FILE = "CODE_MONK_LOGO.png"
CERT_DIR = "."

class SecureWipeWorker:
    """Cross-platform secure wipe worker"""
    
    def __init__(self, entry, level_passes=3, progress_callback=None, status_callback=None):
        self.entry = entry
        self.passes = level_passes
        self.progress_callback = progress_callback
        self.status_callback = status_callback
        self._stop = False
        
    def stop(self):
        self._stop = True
        
    def update_progress(self, percent):
        if self.progress_callback:
            self.progress_callback(percent)
            
    def update_status(self, message):
        if self.status_callback:
            self.status_callback(message)
            
    def run(self):
        """Execute secure wipe process"""
        try:
            device = self.entry["device"]
            display = self.entry.get("display", device)
            
            self.update_status(f"Starting secure wipe of {display}")
            self.update_progress(5)
            
            if self._stop:
                return "Operation cancelled"
                
            # Get platform-specific commands
            commands = get_wipe_commands(device, self.passes)
            total_commands = len(commands)
            
            # Execute each command
            for i, cmd in enumerate(commands):
                if self._stop:
                    return "Operation cancelled"
                    
                self.update_status(f"Executing: {' '.join(cmd[:3])}...")
                success, stdout, stderr = execute_secure_command(cmd)
                
                if not success and "umount" not in cmd[0]:  # umount failures are often OK
                    self.update_status(f"Warning: Command failed - {stderr}")
                    
                progress = int((i + 1) / total_commands * 80) + 5  # 5-85%
                self.update_progress(progress)
                
            # Generate certificate
            self.update_status("Generating completion certificate...")
            self.update_progress(90)
            
            cert_path = self.generate_certificate()
            self.update_progress(100)
            
            return cert_path
            
        except Exception as e:
            return f"ERROR: {str(e)}"
            
    def generate_certificate(self):
        """Generate PDF certificate of completion"""
        if not PDF_AVAILABLE:
            # Create text certificate as fallback
            return self.generate_text_certificate()
            
        now = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        cert_name = os.path.join(CERT_DIR, f"CodeMonk_SecureCertificate_{now}.pdf")
        
        try:
            c = canvas.Canvas(cert_name, pagesize=A4)
            w, h = A4
            
            # Title
            c.setFont("Helvetica-Bold", 18)
            c.drawCentredString(w/2, h - 100, "SECURE FORMAT CERTIFICATE")
            
            # Details
            y = h - 150
            c.setFont("Helvetica", 12)
            c.drawString(80, y, f"Issued by: {COMPANY_NAME}")
            y -= 25
            c.drawString(80, y, f"Target: {self.entry.get('display', self.entry.get('device'))}")
            y -= 25
            c.drawString(80, y, f"Platform: {platform.system()} {platform.release()}")
            y -= 25
            c.drawString(80, y, f"Method: Multi-pass secure wipe ({self.passes} passes)")
            y -= 25
            c.drawString(80, y, f"Date: {datetime.datetime.now().strftime('%d-%m-%Y %H:%M:%S')}")
            y -= 50
            c.drawString(80, y, "Digital Signature: [Generated by Code Monk Secure Formatter]")
            
            c.save()
            return cert_name
            
        except Exception as e:
            return self.generate_text_certificate()
            
    def generate_text_certificate(self):
        """Generate text certificate as fallback"""
        now = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        cert_name = os.path.join(CERT_DIR, f"CodeMonk_Certificate_{now}.txt")
        
        try:
            with open(cert_name, 'w') as f:
                f.write("=" * 60 + "\n")
                f.write("CODE MONK - SECURE FORMAT CERTIFICATE\n")
                f.write("=" * 60 + "\n\n")
                f.write(f"Issued by: {COMPANY_NAME}\n")
                f.write(f"Target: {self.entry.get('display', self.entry.get('device'))}\n")
                f.write(f"Platform: {platform.system()} {platform.release()}\n")
                f.write(f"Method: Multi-pass secure wipe ({self.passes} passes)\n")
                f.write(f"Date: {datetime.datetime.now().strftime('%d-%m-%Y %H:%M:%S')}\n\n")
                f.write("This certificate confirms that the specified storage device\n")
                f.write("has been securely wiped using industry-standard methods.\n\n")
                f.write("Digital Signature: [Generated by Code Monk Secure Formatter]\n")
                f.write("=" * 60 + "\n")
                
            return cert_name
            
        except Exception as e:
            return f"ERROR_CERT: {e}"

class CrossPlatformMainWindow:
    """Cross-platform main window (Qt-based when available)"""
    
    def __init__(self):
        if not QT_AVAILABLE:
            raise RuntimeError("Qt not available - use console version")
            
        self.app, self.framework = create_cross_platform_app()
        self.setup_ui()
        self.worker_thread = None
        self.worker = None
        
    def setup_ui(self):
        """Setup the user interface"""
        # Create main window
        if self.framework == "PyQt5":
            self.window = QtWidgets.QWidget()
        else:  # PyQt6
            self.window = QtWidgets.QWidget()
            
        self.window.setWindowTitle(APP_TITLE)
        self.window.resize(800, 500)
        
        # Dark theme
        self.window.setStyleSheet("""
            QWidget { 
                background-color: #2b2b2b; 
                color: #ffffff; 
                font-family: 'Segoe UI', Arial, sans-serif;
            }
            QPushButton {
                background-color: #404040;
                border: 1px solid #555555;
                padding: 8px;
                border-radius: 4px;
            }
            QPushButton:hover {
                background-color: #505050;
            }
            QPushButton:pressed {
                background-color: #353535;
            }
            QComboBox, QLineEdit {
                background-color: #404040;
                border: 1px solid #555555;
                padding: 5px;
                border-radius: 3px;
            }
            QTextEdit {
                background-color: #1e1e1e;
                border: 1px solid #555555;
                font-family: 'Consolas', monospace;
            }
            QProgressBar {
                border: 1px solid #555555;
                border-radius: 3px;
                text-align: center;
            }
            QProgressBar::chunk {
                background-color: #4CAF50;
                border-radius: 2px;
            }
        """)
        
        layout = QtWidgets.QVBoxLayout(self.window)
        
        # Header
        header = QtWidgets.QLabel(f"<h2>{COMPANY_NAME} — Cross-Platform Secure Formatter</h2>")
        header.setAlignment(QtCore.Qt.AlignCenter)
        layout.addWidget(header)
        
        # Platform info
        platform_info = QtWidgets.QLabel(f"Platform: {platform.system()} {platform.release()}")
        platform_info.setStyleSheet("color: #cccccc; font-size: 10px;")
        layout.addWidget(platform_info)
        
        # Drive selection
        drive_group = QtWidgets.QGroupBox("Drive Selection")
        drive_layout = QtWidgets.QVBoxLayout(drive_group)
        
        drive_row = QtWidgets.QHBoxLayout()
        drive_row.addWidget(QtWidgets.QLabel("Target Drive:"))
        
        self.drive_combo = QtWidgets.QComboBox()
        self.drive_combo.setMinimumWidth(400)
        drive_row.addWidget(self.drive_combo)
        
        self.refresh_btn = QtWidgets.QPushButton("Refresh")
        self.refresh_btn.clicked.connect(self.populate_drives)
        drive_row.addWidget(self.refresh_btn)
        
        drive_layout.addLayout(drive_row)
        layout.addWidget(drive_group)
        
        # Wipe settings
        settings_group = QtWidgets.QGroupBox("Wipe Settings")
        settings_layout = QtWidgets.QHBoxLayout(settings_group)
        
        settings_layout.addWidget(QtWidgets.QLabel("Security Level:"))
        self.level_combo = QtWidgets.QComboBox()
        self.level_combo.addItems(["Quick (1 pass)", "Secure (3 passes)", "Ultra (7 passes)"])
        self.level_combo.setCurrentIndex(1)
        settings_layout.addWidget(self.level_combo)
        settings_layout.addStretch()
        
        layout.addWidget(settings_group)
        
        # Safety confirmations
        safety_group = QtWidgets.QGroupBox("Safety Confirmations")
        safety_layout = QtWidgets.QVBoxLayout(safety_group)
        
        self.ack_checkbox = QtWidgets.QCheckBox("I understand this will PERMANENTLY DESTROY ALL DATA")
        self.ack_checkbox.setStyleSheet("color: #ff6b6b; font-weight: bold;")
        safety_layout.addWidget(self.ack_checkbox)
        
        confirm_row = QtWidgets.QHBoxLayout()
        confirm_row.addWidget(QtWidgets.QLabel("Type 'ERASE' to confirm:"))
        self.confirm_edit = QtWidgets.QLineEdit()
        self.confirm_edit.setMaximumWidth(150)
        confirm_row.addWidget(self.confirm_edit)
        confirm_row.addStretch()
        safety_layout.addLayout(confirm_row)
        
        layout.addWidget(safety_group)
        
        # Progress
        self.progress_bar = QtWidgets.QProgressBar()
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(0)
        layout.addWidget(self.progress_bar)
        
        # Log
        self.log_text = QtWidgets.QTextEdit()
        self.log_text.setReadOnly(True)
        self.log_text.setMaximumHeight(150)
        layout.addWidget(self.log_text)
        
        # Buttons
        button_layout = QtWidgets.QHBoxLayout()
        
        self.start_btn = QtWidgets.QPushButton("START SECURE WIPE")
        self.start_btn.setStyleSheet("QPushButton { background-color: #d32f2f; font-weight: bold; padding: 12px; }")
        self.start_btn.clicked.connect(self.start_wipe)
        button_layout.addWidget(self.start_btn)
        
        self.cancel_btn = QtWidgets.QPushButton("Cancel")
        self.cancel_btn.clicked.connect(self.cancel_operation)
        button_layout.addWidget(self.cancel_btn)
        
        layout.addLayout(button_layout)
        
        # Admin check
        if is_admin():
            self.log("✅ Running with administrator/root privileges")
        else:
            self.log("⚠️ Not running as admin/root - some operations may fail")
            
        # Populate drives
        self.populate_drives()
        
    def populate_drives(self):
        """Populate the drive combo box"""
        self.drive_combo.clear()
        try:
            drives = detect_drives()
            for drive in drives:
                display = drive.get('display', drive.get('device'))
                self.drive_combo.addItem(display, drive)
            self.log(f"Detected {len(drives)} drives")
        except Exception as e:
            self.log(f"Error detecting drives: {e}")
            
    def log(self, message):
        """Add message to log"""
        timestamp = datetime.datetime.now().strftime("%H:%M:%S")
        self.log_text.append(f"[{timestamp}] {message}")
        
    def start_wipe(self):
        """Start the secure wipe process"""
        # Validation
        if not self.ack_checkbox.isChecked():
            QtWidgets.QMessageBox.warning(self.window, "Confirmation Required", 
                                        "You must acknowledge the data destruction warning.")
            return
            
        if self.confirm_edit.text().upper() != "ERASE":
            QtWidgets.QMessageBox.warning(self.window, "Confirmation Required",
                                        "Type 'ERASE' in the confirmation field.")
            return
            
        drive_data = self.drive_combo.currentData()
        if not drive_data:
            QtWidgets.QMessageBox.warning(self.window, "No Drive Selected",
                                        "Please select a drive to wipe.")
            return
            
        # Final confirmation
        reply = QtWidgets.QMessageBox.question(
            self.window, "FINAL WARNING",
            f"This will PERMANENTLY DESTROY all data on:\n\n{drive_data.get('display')}\n\nThis action CANNOT be undone!\n\nProceed?",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
            QtWidgets.QMessageBox.No
        )
        
        if reply != QtWidgets.QMessageBox.Yes:
            return
            
        # Start worker thread
        passes = [1, 3, 7][self.level_combo.currentIndex()]
        self.worker = SecureWipeWorker(
            drive_data, passes,
            progress_callback=self.progress_bar.setValue,
            status_callback=self.log
        )
        
        self.worker_thread = threading.Thread(target=self.run_worker)
        self.worker_thread.daemon = True
        self.worker_thread.start()
        
        self.start_btn.setEnabled(False)
        self.log("Secure wipe operation started...")
        
    def run_worker(self):
        """Run worker in thread"""
        result = self.worker.run()
        
        # Update UI in main thread
        QtCore.QTimer.singleShot(0, lambda: self.wipe_finished(result))
        
    def wipe_finished(self, result):
        """Handle wipe completion"""
        self.start_btn.setEnabled(True)
        
        if result.startswith("ERROR"):
            QtWidgets.QMessageBox.critical(self.window, "Operation Failed", result)
            self.log(f"Operation failed: {result}")
        else:
            QtWidgets.QMessageBox.information(self.window, "Operation Complete", 
                                            f"Secure wipe completed successfully!\n\nCertificate saved: {result}")
            self.log(f"Operation completed. Certificate: {result}")
            
        self.progress_bar.setValue(0)
        
    def cancel_operation(self):
        """Cancel the current operation"""
        if self.worker:
            self.worker.stop()
            self.log("Cancellation requested...")
        else:
            self.window.close()
            
    def show(self):
        """Show the window"""
        self.window.show()
        
    def exec(self):
        """Run the application"""
        return self.app.exec_() if hasattr(self.app, 'exec_') else self.app.exec()

def main():
    """Main entry point"""
    try:
        if QT_AVAILABLE:
            window = CrossPlatformMainWindow()
            window.show()
            return window.exec()
        else:
            print("GUI not available - Qt framework not found")
            print("Please install PyQt5 or PyQt6 for GUI mode")
            return 1
    except Exception as e:
        print(f"Error starting application: {e}")
        return 1

if __name__ == "__main__":
    sys.exit(main())
